{\rtf1\ansi\deff0
{\fonttbl{\f0 Calibri;}{\f1 Times New Roman;}}
{\colortbl;\red0\green0\blue0;}
\f0\fs24\b Depreciation Report Documentation\b0\par
\par
\f1\fs22 1. Purpose and Scope\par
This document describes the Depreciation Report generated by the Assets service, including the data fields returned to the frontend, the formulas used to compute depreciation metrics, rationale for the calculations, edge cases handled, and implementation notes for developers and QA.\par
\par
2. Data Source\par
- Source: the `generate_depreciation_report()` service in the Assets backend (assets_ms.services.depreciation_report).\par
- Input records: Asset rows joined to Product (product.depreciation), optional AssetCheckout records for deployed-to information, and context lookups for depreciation definitions and status names.\par
\par
3. Output fields (returned per asset)\par
Each row contains these keys (frontend expects these names):\par
- id: internal asset DB id.\par
- assetId: public identifier string for the asset (e.g., AST-20251219-00001-6017).\par
- product: product name.\par
- statusType: machine code/slug for status (may be blank if not provided by contexts).\par
- statusName: human label for status (e.g., "Deployable").\par
- deployedTo: (nullable) name of the person to whom the asset is currently deployed (from AssetCheckout if available).\par
- depreciationName: human label/name of the depreciation profile applied to the product.\par
- duration: depreciation duration in months (integer).\par
- currency: currency symbol used for amounts (e.g., \u8369?).\par
- minimumValue: minimum residual value (numeric, 2-decimal).\par
- purchaseCost: purchase cost used for calculations (numeric, 2-decimal).\par
- currentValue: asset's value at report date (numeric, 2-decimal).\par
- depreciated: total amount depreciated so far (numeric, 2-decimal).\par
- monthlyDepreciation: monthly depreciation amount (numeric, 2-decimal).\par
- monthsLeft: integer months remaining until end of depreciation (non-negative).\par
\par
4. Core formulas and algorithm (summary)\par
Notation: let\par
\tab P = purchase cost (purchaseCost)\par
\tab M = minimum residual value (minimumValue)\par
\tab D = duration in months (duration)\par
\tab t = months elapsed since purchase (months_elapsed), computed from purchase_date to report date\par
\tab max(a,b) = the greater of a and b\par
\par
1) Depreciable amount (A):\par
\tab A = max(0, P - M)\par

2) Monthly depreciation (m):\par
\tab If A = 0 or D <= 0 then m = 0. Else:\par
\tab m = A / D\par

3) Depreciated to date (Dep):\par
\tab Dep = min(t * m, A)\par

4) Current value (CV):\par
\tab CV = max(M, P - Dep)\par

5) Months left (L):\par
\tab L = max(D - t, 0)\par

Notes on implementations:\par
- All currency math in the service is performed using Decimal with rounding, then returned as float with 2-decimal precision to the API (to stabilize frontend formatting).\par
- Months elapsed (t) counts whole calendar months. If the day-of-month in the report date is before the purchase day, the partial month is not counted (e.g., purchase on Jan 15 and report on Feb 14 gives 0 full months elapsed).\par
\par
5. Reasoning / why these formulas\par
- The method used is straight-line depreciation cut to months: the asset loses an equal portion of the depreciable amount every month across the configured duration.\par
- Minimum residual value (M) protects against negative book values and supports business rules such as a salvage value or minimum market value.\par
- Clamping using `max` and `min` ensures numeric stability and prevents negative monthly depreciation when purchase cost <= minimum value.\par
- Using months (integer) aligns with accounting simplicity for asset tracking and matches the UI which displays months left and monthly depreciation.\par
\par
6. Edge cases and handling\par
- Missing purchase_cost: purchase cost falls back to product.default_purchase_cost when present; otherwise 0.\par
- Purchase cost <= minimum value: depreciable amount A becomes 0, monthlyDepreciation = 0, depreciated = 0, currentValue = minimumValue.\par
- Duration missing: default duration used (36 months unless adjusted in code).\par
- Duration <= 0: treated as zero (monthlyDepreciation = 0).\par
- Future purchase_date: months elapsed computed as 0 (asset not yet depreciated).\par
- Missing depreciation context or unexpected structure: the service supports both dict-like and object-like returns from contexts; missing fields fall back to defaults.\par
\par
7. Implementation notes (backend)\par
- Code location: `backend/assets/assets_ms/services/depreciation_report.py`\par
- Uses `get_depreciation_by_id()` and `get_status_by_id()` from contexts to resolve names and parameters. Ensure those functions return a predictable structure (dict keys: name/display_name/duration/minimum_value/currency) or adapt this service to accept model objects.\par
- Currency math uses `Decimal` internally and quantizes amounts to 2 decimals when sending to API. This avoids typical floating point rounding issues.\par
- `deployedTo` is derived from `AssetCheckout` where available; implementation tries common field names (`is_returned`, `returned`, `active`, `person_name`, `deployed_to`, `person.get_full_name()`). Make sure your checkout model's field names are supported or adjust code accordingly for accurate deployed-to values.\par
- API exposure: `backend/assets/assets_ms/api/reports.py` provides `reports/depreciation/` endpoint. Add `?format=json` to that URL to receive JSON results consumed by the frontend.\par
\par
8. Frontend mapping and display notes\par
- The frontend `DepreciationReport.jsx` expects the keys shown in section 3 and formats numeric values with two decimals.\par
- `statusType` is used for machine logic (e.g., color) and `statusName` for UI label. If `statusType` is empty, Status component should gracefully fall back to a neutral style.\par
- `deployedTo` (nullable) can be shown as a person name; omit or hide when null.\par
\par
9. Example calculation\par
Given:\par
- P = 2,499.00\par
- M = 200.00\par
- D = 36 months\par
- Suppose purchase date was 3 months ago, so t = 3.\par
\par
A = max(0, 2499.00 - 200.00) = 2299.00\par
m = 2299.00 / 36 = 63.861111... -> displayed 63.86 (rounded)\par
Dep = min(3 * 63.861111..., 2299.00) = 191.583333... -> displayed 191.58\par
CV = max(200.00, 2499.00 - 191.5833...) = 2307.416666... -> displayed 2307.42\par
L = max(36 - 3, 0) = 33 months\par
\par
10. Test suggestions (unit tests)\par
- Asset with purchaseCost = 0, ensure monthlyDepreciation = 0 and currentValue = minimumValue.\par
- Asset with purchaseCost <= minimumValue, ensure behaviours above.\par
- Asset with future purchase_date, ensure months_elapsed = 0 and no negative values.\par
- Depreciation duration = 0 or negative: no division by zero and monthlyDepreciation = 0.\par
- Depreciation context returned as object instead of dict: service handles both. Test both shapes.\par
- Check rounding behavior: ensure values are rounded to two decimals when returned to API.
\par
11. Deployment / usage notes\par
- API endpoint: `GET /api/assets/reports/depreciation/?format=json` (or via API gateway base URL).\par
- Frontend will call this endpoint and render the returned list; the existing `DepreciationReport.jsx` has been updated to fetch this JSON automatically.\par
\par
12. Change log / authorship\par
- Created by: project service team (auto-generated documentation from code review).\par
- File created: Depreciation_Report_Documentation.rtf in project root.\par
\par
---\par
End of document.
}
